# GIT REBASE

## Что это такое?

Git rebase - перезапись истории коммитов в текущей ветке, начиная с указанного коммита

## Обычный git rebase: когда использовать?

### Обновление ветки перед слиянием

Когда Вы готовы создать Pull Request, или исправили все замечания и готовы к слиянию, необходимо выполнить следующие
шаги:

```bash
git fetch -p
git checkout master
git pull
git checkout <your branch>
git rebase master
```

Или быстрый вариант (нежелательно, только в случае, если спешите):

```bash
git fetch -p
git rebase origin/master
```

### Обновление текущей рабочей ветки

Если в случае выполнения команды

```bash
git push --force-with-lease
```

у Вас появилась ошибка, необходимо переписать историю коммитов, подтянув изменения, сделанные другим разработчиком:

```bash
git fetch -p
git rebase origin/<branchname>
```

После выполнения данных команд можно будет сделать push.

## Интерактивный git rebase

Интерактивный rebase позволяет переписывать историю коммитов: объединять, переименовывать, удалять и менять порядок
коммитов.

Если Вам поступили правки в комментариях к PR, Вам ни в коем случае нельзя писать исправляющие коммиты.
Вам нужен Git rebase -i.
Необходимо следовать следующей инструкции
(помните, что на любом шаге Вы можете выполнить команду `git rebase --abort` - это отменит ВСЕ изменения, что Вы сделали при интерактивном rebase):

1. Определить проблемные коммиты, которые нужно будет исправить
2. Скопировать хэш самого первого проблемного коммита (или посчитать количество коммитов после первого проблемного
   включительно)
3. Выполнить команду
   ```bash
   git rebase -i <commithash>
   ```
   или
   ```bash
   git rebase -i HEAD~<количетсов коммитов ПОСЛЕ первого проблемного ВКЛЮЧИТЕЛЬНО>
   ```
4. После запуска команды откроется редактор со списком коммитов формата:
   ```bash
   pick <shorthash1> commit description 1
   pick <shorthash2> commit description 2
   ...
   ```
5. `pick` - ключевое слово. Ключевые слова используются для изменения истории коммитов. Таких слов много, я перечислю
   основные:

   | Команда | Описание                                                       | Пример использования             |
   |---------|----------------------------------------------------------------|----------------------------------|
   | pick    | Оставить коммит как есть (используется по умолчанию)           | pick a1b2c3d Add function        |
   | reword  | Оставить коммит, но изменить его сообщение                     | reword a1b2c3d Fix description   |
   | edit    | Остановиться на этом коммите для внесения изменений            | edit a1b2c3d Add tests           |
   | squash  | Объединить коммит с предыдущим (сообщения тоже объединятся)    | squash a1b2c3d Improve codestyle |
   | fixup   | Объединить коммит с предыдущим, но отбросить его сообщение     | fixup a1b2c3d Fix function       |
   | drop    | Удалить коммит из истории                                      | drop a1b2c3d Some old commit     |
   | break   | Приостановить rebase в этом месте (можно внести ручные правки) | break                            |

   Все ключевые слова, кроме `break`, пишутся в формате `<keyword> <commithash> <commitmsg>`
   - pick = применить коммит (оставить без изменений)
   - reword = переименовать коммит (откроется текстовый редактор для переименования)
   - (!) edit = остановка __на указанном коммите__. Это значит, что после редактирования нужных файлов, нужно добавить их в индекс командой `git add` или `git add -u` и далее написать `git rebase --continue`
   - (!) break (обратите внимание на синтаксис) = разделение rebase на этапы. Это значит, что Вы можете добавить коммит(-ы) между теми коммитами, где Вы применили это ключевое слово
   - (!) drop = удаление коммита из истории
   - fixup = объединение указанного коммита с предыдущим без объедиения комментариев (остаётся комментарий, указанный в коммите, к которому указанный коммит присоединится)
   - squash = аналог fixup, но при его использовании все сообщения объединяются через перенос строки

   (!) Вы также можете менять порядок коммитов: просто поменять местами строки с их хэшами. Т.е. если Вы просто хотите поменять два коммита местами, поменяйте местами строки `pick <hashcommit1> ...` и `pick <hashcommit2> ...`

   Наверняка Вы обратили внимание на восклицательные знаки перед некоторыми командами. Я пометил их, так как они способны вызвать конфликты. В следующем разделе расскажу об их разрешении.
6. Когда все настройки применены, необходимо сохранить файл, открытый в редакторе (в nano это делается нажатием Ctrl + O, в mcedit - f2, в vim - :wq!).
7. Ура! Вы в интерактивном режиме! В случае, если Вы ошиблись, Вы можете набрать команду `git rebase --abort` - это отменит все изменения
8. Для перехода на следующий шаг введите `git rebase --continue`. Возможно, появятся ошибки. Это значит, что Вы отредактировали файлы и не добавили их в индекс. Вам необходимо добавить их через `git add` или `git add -u`, и затем повторить команду.
9. Когда Вы увидите сообщение `Successfully rebased ...!`, это значит, что история переписана, и можно делать push по описанной в [Git Flow](./git-flow.md) инструкции

### Разрешение конфликтов
Так как Git делает shapshot файлов, а не вычисляет разницу между ними, в процессе rebase (особенно, интерактивном) зачастую возникают __конфликты__ - это когда git не понимает, какие изменения должны быть применены.

Например, Вы изменили строчки 1 и 12 в файле ttt.txt в коммите А. Затем кто-то сделал Pull Request, добавив в master коммит Б.
Вам пришлось сделать rebase master, подтянув коммит Б:
```bash
git fetch -p
git rebase new_branch
```

В коммите Б, как оказалось, есть изменения на строчках 12 и 13 файла ttt.txt.
В таком случае git спросит Вас: "Как объединяем изменения из коммитов А и Б на строчках 12 и 13?". Это будет выглядеть так:
```
Auto-merging ttt.txt
CONFLICT (content): Merge conflict in ttt.txt
Automatic merge failed; fix conflicts and then commit the result.
```

Когда Вы откроете файл, Вы увидите что-то вроде этого:
```
1-я строчка из коммита А
...остальной контент...
<<<<<<< HEAD
строка 12 из коммита А
=======
строка 12 из коммита Б
строка 13 из коммита Б
>>>>>>> hashofcommitB
... остальной контент
```

Видно, что в файле появились новые странные дополнения:
 - `<<<<<<< HEAD`
 - `=======`
 - `>>>>>>> hashofcommitB`

Эти новые строки можно рассматривать как «разделители конфликта». Строка ======= является «центром» конфликта.
Все содержимое между этим центром и строкой <<<<<<< HEAD находится в текущей ветке, на которую ссылается указатель HEAD.
А все содержимое между центром и строкой >>>>>>> hashofcommitB является содержимым коммита Б.

На этом этапе стоит посмотреть, что за коммит сейчас в HEAD:
```bash
git show
```

Именно в этом коммите сохранится разрешение конфликта.

Необходимо выбрать, какие изменения останутся, а какие - нет. Нужно просто отредактировать файл, удалив разделители и оставив только нужные изменения.
Когда это будет сделано, нужно ввести команду `git add -u <путь_до_файла>`, затем - `git rebase --continue`. "Под капотом" выполнится команда
```bash
git commit --amend
```

После этого ребейз продолжится, перейдя к следующему конфликту, или закончится.

(!) Важно: изменяйте _только коммиты в своей ветке_, по возможности, не изменяя коммиты других авторов. Уважаем чужой код.
Коммиты из ветки master не изменяем - делаем новые только поверх.

В случае, если Вы случайно разрешили конфликт в коммите из другой ветки, будет создан новый коммит с таким же названием.
Проверьте, верно ли Вы разрешили коммит. Сделайте fixup для этого коммита с тем, который вызвал конфликт, или сделайте drop.

Важно понимать, что, если чужой Pull Request был слит в master и вызвал конфликт в Вашей ветке, вины автора PR в этом нет.
Ответственность за разрешение конфликта на Вас.

#### Частный случай
Конфликты могут возникать и в случае выполнения `git pull --rebase`. В таком случае новые коммиты конфликтуют со старыми.
Запомните: старые коммиты применяются поверх новых. Если Вы что-то не так отребейзили, у Вас появятся "дубли" - коммиты с одинаковыми названиями.
Чтобы исправить ситуацию, просто сделайте drop для верхнего "дубля".

Та же практика применима для любого ребейза: появляются "дубли" - делаем fixup или drop.

#### Литература
Подробнее о rebase и о конфликтах можно почитать здесь:
 - https://habr.com/ru/articles/161009/ (rebase)
 - https://www.atlassian.com/ru/git/tutorials/using-branches/merge-conflicts (конфликты просто)
 - https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-using-the-command-line (конфликты сложно)
